---
title: Web √©s HTTP
subject: hau
description: "HTTP(S) √©s verzi√≥i, web gyors√≠t√≥t√°r, f√°jl√°tvitel, e-mail √©s SMTP, domain n√©v szolg√°ltat√°s."
date: 2020-05-22
---

**HTTP**: HyperText Transfer Protocol.
**weboldal**: HTML nyelven √≠rt oldal, ami tov√°bbi hivatkozott **objektum** okat is tartalmaz.

Egy objektum lehet k√©p, hang, vide√≥, program, stb.
Az objektumok nem felt√©tlen√ºl ugyanazon a szerveren tal√°lhat√≥ak.
Egy objektumra **URL** - lel hivatkozunk (Uniform Resource Locator)
pl.: `http://www.someschool.edu/fooldal/assets/imgs/kep.jpg`

Itt a **.edu** - ig a szerver **hosztneve** van, ut√°na pedig a **f√°jlhoz vezet≈ë el√©r√©si √∫t** (Mint a C:\\Users\stb)

A **HTTP** a Web **alkalmaz√°si r√©teg** protokollja.
**Kliens** a b√∂ng√©sz≈ë ami objektumokat k√©r, fogad √©s jelen√≠t meg.
**Szerver** a webszerver ami objektumokat k√ºld mikor a kliensek k√©rik.

HTTP verzi√≥k: 1.0, 1.1, 2, 3

# HTTP

TCP sz√°ll√≠t√°si protokoll felett kommunik√°l. Kommunik√°ci√≥ menete:

- Kliens TCP kapcsolatot k√©r a 80-as porton (ez a http szabv√°nyos portja)
- Szerver ezt elfogadja, majd l√©trej√∂n a kapcsolat
- √úzeneteket v√°ltanak
- TCP kapcsolat lez√°rul
- Mindezek al√≥l kiv√©tel a HTTP/3 mert az QUIC sz√°ll√≠t√°si protokollra √©p√ºl. A QUIC pedig hibrid HTTP √©s UDP. UDP, pedig mint tudjuk, nem √©p√≠t kapcsolatot, √©s egyebek.

√úzenett√≠pusok: **K√âR√âS** (request), **V√ÅLASZ** (response)

**√Ållapotmentes** protokoll: szervert nem √©rdekli hogy kor√°bban milyen kliensek kapcsol√≥dtak √©s milyen k√©r√©seik voltak.

**Nem perzisztens** : Fel√©p√≠tett kapcsolatonk√©nt 1 objektum lesz elk√ºldve. Ilyen volt a **HTTP/1.** Itt az√©rt √©rezz√ºk, hogy ha egy weboldalon van 10 k√©p, √©s mindegyikhez egy √∫j TCP kapcsolatot kell √©p√≠teni, majd lebontani, az mennyire nem hat√©kony.

**Perzisztens** : √∂sszes objektum let√∂lt≈ëdik egy kapcsolaton. Ez jellemz≈ë **HTTP/ 1 .1-t≈ël**

## Id≈ëig√©nyek

### Nem perzisztens HTTP:

Minden objektumra: **3\*RTT+√°tviteli_id≈ë**

A 3\*RTT a k√∂vetkez≈ëkb≈ël √°ll:

- Kapcsolat fel√©p√≠t√©se
- HTTP k√©r√©s/v√°lasz els≈ë b√°jtj√°nak meg√©rkez√©se
- √Åtvitel ut√°n, kapcsolatbont√°s

Az √°tviteli id≈ë az az id≈ë, am√≠g az objektum meg√©rkezik a klienshez.
Teh√°t ez √∂sszesen ha minden objektumot bele√≠runk a k√©pletbe:

**(3\*RTT+√°tviteli_id≈ë)\*n**

Ahol **n** az objektumok sz√°ma, az √°tviteli_id≈ë pedig az √©ppen aktu√°lis objektum √°tviteli ideje.

### Perzisztens HTTP

Ebben az esetben a TCP kapcsolat nyitva marad. Nem kell objektumonk√©nt fel√©p√≠teni √©s lebontani √∫jra.

**Pipelining n√©lk√ºl**:

Kliens csak akkor k√ºld √∫j k√©r√©st, ha az el≈ëz≈ë objektum meg√©rkezett Teh√°t ez annyival jobb mint a nem perzisztens HTTP, hogy nem kell minden objektumra √∫j TCP kapcsolatot √©p√≠teni √©s bontani.

A k√©r√©s + v√°lasz id≈ëig√©nye: **1\*RTT** minden objektumra.

N objektum id≈ëig√©nye: **(1+n+1)\*RTT+√°tviteli_id≈ë**

Ahol **1** a kapcsolat √©p√≠t√©s, **n** az objektumok sz√°ma, **1** a kapcsolat bont√°s.

**Pipelining-al**

Kliens minden objektumra azonnal k√©r√©st k√ºld. A k√©r√©s + v√°lasz id≈ëig√©nye: **1\*RTT**

N objektum id≈ëig√©nye: **(1+1+1)\*RTT+√°tviteli_id≈ë**

Ahol **1** a kapcsolat √©p√≠t√©s, **1** a k√©r√©s v√°lasz, **1** a kapcsolat bont√°s. Ez a m√≥dszer alap√©rtelmezett HTTP/1.1-t≈ël.

Ism√©tl√©s:

**RTT** = K√∂r√ºlfordul√°si id≈ë. Am√≠g egy csomag el√©r egyik helyr≈ël a m√°sikra, majd vissza.

## HTTP met√≥dusok

### HTTP/1.0

- GET:
  - Obejktum let√∂lt√©se az URL alapj√°n.
  - ≈∞rlap adat (form) felt√∂lt√©se URL-ben l√©v≈ë inform√°ci√≥k√©nt (query param√©terek `valami.hu/?search=szia&limit=10`) (ezzel csak √≥vatosan, loginn√°l √©s hasonl√≥kn√°l ne er≈ëltess√ºnk ilyesmit)
- POST:
  - ≈∞rlap adat felt√∂lt√©se az √ºzenet t√∂rzs√©ben (request body) (ez am√∫gy nem korl√°toz√≥dik csak ≈±rlapokra.)
- HEAD
  - Csak fejl√©c (pl. hibakeres√©sre)

### HTTP/1.1 √∫j met√≥dusok

- PUT:
  - F√°jl felt√∂lt√©se adott k√∂nyvt√°rba (igaz√°b√≥l a CRUD-nak ez az update r√©sze. Az eg√©sz objektumot √∫jra kell k√ºldeni √©s √≠gy friss√ºl egy m√°r megl√©v≈ë objektum amit a POST met√≥dussal hoztunk l√©tre.) (nem csak f√°jlra limit√°lt)
- DELETE:
  - F√°jl t√∂rl√©se a k√∂nyvt√°rb√≥l (szint√©n, nem csak f√°jlra limit√°lt)

Itt legink√°bb annyi a l√©nyeg, hogy tudjuk, hogy GET POST √©s HEAD volt csak el≈ësz√∂r. Minden m√°s az m√°r √∫j verzi√≥k b≈ëv√≠t√©sei. Az amikor felm√©sz fb-re az egy GET k√©r√©s. Az amikor kit√∂ltesz egy Google Formot √©s bek√ºld√∂d, vagy csak bel√©psz b√°rhova, az egy POST k√©r√©s. A **CRUD** (create, read, update, delete) m≈±veletekhez (REST API) A POST, GET, PUT, DELETE met√≥dusokat haszn√°ljuk. (PATCH hasonl√≥ mint a PUT)

## HTTP k√©r√©s√ºzenet

```http
GET /eleresi_ut/valami/oldal.html
Host: www.example.com
User-agent: Mozilla/4.0
Connection: close
Accept-language: hu

(Body)
```

Itt az els≈ë sorban `GET /eleresi_ut/valami/oldal.html` tal√°ljuk a met√≥dust (GET) √©s a relat√≠v el√©r√©si utat (URL) (minden a GET ut√°n).
Az ez alatt l√©v≈ë 4 sort fejl√©c soroknak nevezz√ºk. Itt vannak mindenf√©le szabv√°nyos fejl√©cek `mez≈ën√©v: √©rt√©k` form√°tumban. Ez ut√°n j√∂n a Body, ami lehet JSON, XML √©s stb.

## HTTP v√°lasz√ºzenet

Fel√©p√≠t√©se kb ugyan az mint a k√©r√©snek.

```http
HTTP/1.1 200 OK
Connection close
Date: k√©pzelj√ºnk ide egy d√°tum stringet
Server: Apache/1.3.0 (Unix)
Content-Length: 6821
Content-Type: text/html

data data data data
```

Els≈ë sorban van a http verzi√≥, ami √©pp most 1.1, ut√°na a st√°tuszk√≥d (200), √©s a st√°tuszk√≥d sz√∂veggel is (OK)
Ezut√°n ism√©t fejl√©c mez≈ëk, majd az adat.

Ezeknek az √ºzeneteknek legink√°bb az els≈ë sor√°r√≥l √©rdemes tudni valamit. Kapcsol√≥dhat hozz√° socket
feladat, vagy k√©rd√©s.

## HTTP st√°tuszk√≥dok (√°llapotk√≥dok)

- 200 OK
  - Sikeres k√©r√©s, a k√©rt objektum az √ºzenetben van.
- 301 Moved Permanently
  - A k√©rt objektum m√°r nem ezen a c√≠men √©rhet≈ë el, az √∫j helye meg van adva az √ºzenetben
- 400 Bad Request
  - A szerver nem √©rti a k√©r√©s √ºzenetet (4xx st√°tuszk√≥dok azt mondj√°k, hogy valami te, a kliens rontott el!)
- 403 Forbidden
  - Az objektumhoz val√≥ hozz√°f√©r√©s megtagadva
- 404 Not Found
  - A k√©rt objektum (er≈ëforr√°s) nincs a szerveren
- 505 HTTP Version Not Supported
  - A k√ºld√©skor jelzett HTTP protokoll v√°ltozatot a szerver nem t√°mogatja
- 500 Internal Server Error
  - Nagy a baj a szerveren üòÇ

## √öjabb HTTP verzi√≥k

**HTTP/2 (http/1.x kiterjeszt√©se)**

Gyorsabb, van benne priorit√°s. Szerver oldali PUSH t√°mogatott, vagyis k√©r√©s n√©lk√ºl is k√ºld objektumokat. Csak egy TCP kapcsolat √©p√ºl fel.

**HTTP/3 (nem kiterjeszt√©s!!)**

TCP helyett QUIC protokollt haszn√°l. Gyorsabb kapcsolat fel√©p√≠t√©st tesz lehet≈ëv√© tan√∫s√≠tv√°nyokkal. (Mindegy, hogy most mi az a tan√∫s√≠tv√°ny)

## √Ållapot kezel√©s s√ºtikkel

A legt√∂bb weboldal haszn√°l s√ºtiket (**cookie**). A s√ºtik elmennek a HTTP k√©r√©s √©s v√°lasz √ºzenetekben is. A kliens t√°rolja a s√ºtiket, √©s a b√∂ng√©sz≈ëje kezeli azokat. Van egy h√°tt√©r adatb√°zis a webszerveren is.

Mire haszn√°lhat√≥?

- felhaszn√°l√≥ azonos√≠t√°sa (erre manaps√°g a token alap√∫ megold√°sok m√°r a nyer≈ëbbek)
- Felhaszn√°l√≥ munkamenet vagy folyamat √°llapot√°nak t√°rol√°sa, pl. Kos√°r tartalma
- Aj√°nl√°sok

Szem√©lyes adatok v√©delme

- A s√ºtik alapj√°n rengeteg dolgot meg lehet tudni a felhaszn√°l√≥r√≥l
- √ârz√©keny adatok is lehetnek benn√ºk
- Az EU-ban j√≥v√° kell hagynunk a haszn√°lat√°t (thx EU, m√©g1 popup amire mindig r√° lehet kattintani)

# HTTPS

- biztons√°gos webel√©r√©s
- hiteles√≠t√©s: az oldal t√©nyleg az akinek mondja mag√°t
- titkos√≠t√°s: sima sz√∂veg helyett tikos√≠tott adat√°tvitel
- Ez a 80-as TCP port helyett, m√°r a 443-as TCP portot haszn√°lja

# WEB gyors√≠t√≥t√°r (CACHE)

Tegy√ºk fel, van egy weboldal, ami 10 √©ve semmit sem v√°ltozott. Mi a jobb nek√ºnk? Az ha a szomsz√©d Cache szerverr≈ël t√∂lt√∂m le azt a weboldalt, vagy ha elmegyek egy m√°sik kontinensre az√©rt a weboldal√©rt mindig, ami am√∫gy 10 √©ve nem v√°ltozott?

Nyilv√°n az els≈ë verzi√≥ kicsit kellemesebb, na meg j√≥val gyorsabb is, arr√≥l nem is besz√©lve, hogy a t√°voli szerverr≈ël el√©g sok terhel√©st levesz, hiszen csak akkor k√©ri t≈ële a Cache szerver a weboldalt, ha az megv√°ltozott. Amennyibben nem t√∂rt√©nt ilyesmi, a t√°voli szerver k√∂zrem≈±k√∂d√©se n√©lk√ºl is megkaphatjuk a weboldalt a Cache-b≈ël.

Teh√°t a kliens minden k√©r√©st a Cache szervernek k√ºld el≈ësz√∂r. Ha ott megvan a k√©rt oldal, √©s up to date, nagy a boldogs√°g, m√°r kapjuk is meg az oldalt. Ha nem up to date, akkor friss√≠ti a Cache szerver, √©s az √∫j oldalt kapjuk meg.

A Cache ez√©rt kliens √©s szerver is egyben.

Cache-t (gyors√≠t√≥t√°rat) az ISP (szolg√°ltat√≥, v√°llat, int√©zm√©ny) szokott telep√≠teni.

El≈ënyei:

- RTT ideje cs√∂kken
- Nyilv√°nos csatlakoz√°si kapcsolat leterhelts√©ge cs√∂kken, mert helyben a Cache szerverr≈ël szedj√ºk le az oldalt ha lehet.
- Ha s≈±r≈±n vannak a Cache szerverek, akkor azok is k√∂nnyen tudj√°k terjeszteni a szolg√°ltat√°saikat akiknek, am√∫gy nem nagyon van j√≥ szervere, vagy h√°l√≥zati kapcsolata.

# F√°jl√°tvitel

FTP ‚Äì File Transfer Protocol

Kliens szerver modellt haszn√°l.

Kliens: az √°tvitelt kezdem√©nyez≈ë f√©l, aki t√°volr√≥l vagy t√°volra szeretne f√°jl m√°solni.
Szerver: a t√°voli hoszt

**S√°von k√≠v√ºli (Out of band)** vez√©rl√©st haszn√°l.
Ez annyit jelent, hogy van egy kapcsolat a vez√©rl√©snek, √©s van egy kapcsolat k√ºl√∂n a f√°jl√°tvitelnek.

**Nem √°llapotmentes** , vagyis, a szerver megjegyzi azt, hogy a kliensek mit csin√°ltak.

Hogyan t√∂rt√©nik a f√°jl√°tvitel?

1. Az FTP kliens csatlakozik az FTP szerverhez a 21-es TCP porton
2. A kliens azonos√≠t√°sa a vez√©rl√©si √∂sszek√∂ttet√©sen
3. A kliens √°ttekintheti a t√°voli k√∂nyvt√°rakat megfelel≈ë parancsokat k√ºldve a vez√©rl√©si √∂sszek√∂ttet√©sen (Mindenki l√°tott m√°r total commandert, na itt kb azt kell elk√©pzelni, csak az egyik oldala nem a saj√°t g√©pen van hanem messze az ftp szerveren. ha nem grafikus fel√ºlet akkor parancssorban lehet n√©zni ezeket a szok√°sos parancsokkal, miut√°n kapcsol√≥dtunk a szerverre)
4. A mikor f√°jl√°tvitel parancs √©rkezik a szerver nyit egy √∫jabb TCP √∂sszek√∂ttet√©st (a 20-as porton) a kliens fel√© a f√°jl √°tvitel√©hez
5. A f√°jl √°tvitele ut√°n a szerver lez√°rja ezt a TCP √∂sszek√∂ttet√©st, de a vez√©rl√©si kapcsolat tov√°bb √©l, √©s ugrunk a 3. l√©p√©sre

Az FTP nem biztons√°gos √©s mindent k√ºl√∂n paranccsal kell let√∂lteni, ezek kellemetlen probl√©m√°k. Erre az egyik forgalomban l√©v≈ë megold√°s az SFTP vagyis SSH File Transfer Protocol. Ez biztos√≠t titkos√≠tott ssh alap√∫ √°tvitelt a 22-es TCP porton. (Secure CoPy kb ugyanez, de ez csak f√°jl√°tvitelre k√©pes)

# Elektronikus levelez√©s

levelez≈ë szerver fel√©p√≠t√©se:

- postafi√≥k: felhaszn√°l√≥ itt t√°rolja a bej√∂v≈ë √ºzeneteit
- kimen≈ë √ºzenetsor (message queue): elk√ºldend≈ë levelek vannak itt

Levelez≈ë kliens (Mail User Agent):

- Azt tudja mint egy outlook.
- lev√©l √≠r√°sa, szerkeszt√©se, olvas√°sa
- lev√©l k√ºld√©se illetve lek√©r√©se szerverr≈ël

Szerepek:

- MUA - Mail User Agent: a fentebbi
- MSA - Mail Submission Agnet: ez k√ºldi el a levelet
- MTA - Mail Transfer Agent: ez viszi el a levelet
- MDA - Mail Delivery Agent: ez hozza meg a levelet

Hogy t√∂rt√©nik a lev√©lk√ºld√©s?

1. B√©la a MUA seg√≠ts√©g√©vel √≠r egy levelet √©s megc√≠mzi erre a c√≠mre: `jozsi@valami.hu`
2. B√©la MUA-ja elk√ºldi a levelet B√©la levelez≈ë szerver√©nek (MSA) ami beteszi a kimen≈ë levelek sor√°ba.
3. B√©la levelez≈ëszervere (MTA) kapcsolatot l√©tes√≠t J√≥zsi levelez≈ë szerver√©vel (MTA)
4. Elk√ºldi a levelet (MTA)
5. J√≥zsi szervere (MDA) bedobja a levelet J√≥zsi postafi√≥kj√°ba
6. J√≥zsi a MUA seg√≠ts√©g√©vel elolvassa a levelet.

## SMTP protokoll

TCP-t haszn√°l a levelek k√ºld√©s√©re a 25-√∂s porton. K√∂zvetlen√ºl √°tviszi a levelet a k√ºld≈ët≈ël a fogad√≥hoz.

El≈ësz√∂r fel√©p√≠ti a kapcsolatot, elk√ºldi az √ºzenetet, azt√°n lez√°rja a kapcsolatot.

Probl√©m√°i, hogy csak sz√∂veget tud k√ºldeni, valamint az azonos√≠t√°s √©s az adatbiztons√°g hi√°nyzik.

## Lev√©l hozz√°f√©r√©si protokollok

POP3: ennek a be√°ll√≠t√°s√°t kell tudni laboron. Sz√∂veges parancsai/v√°laszai vannak, van azonos√≠t√°s.

IMAP: http alap√∫ megval√≥s√≠t√°sa pl a Gmail. Kb azt tudja amit a Gmail is. (az alap dolgaira kell gondolni)

# Domain n√©v szolg√°ltat√°s

A 172.76.45.32-t be√≠rni a b√∂ng√©sz≈ëbe, h√°t mondjuk √∫gy el√©g kellemetlen. Megjegyezni meg azt√°n f≈ëleg. De ha azt k√©ne be√≠rni √©s megjegyezni, hogy google.com, akkor m√°ris jobban menne nem? Na pont ezt oldja meg a **DNS** (Domain Name System), ami **egy alkalmaz√°s r√©tegbeli** protokoll.

Szolg√°ltat√°sai, avagy mire is j√≥ ez:

- Cs√∫nya IP c√≠met sz√©p n√©vre ford√≠tja, mint a fenti p√©ld√°ban.
- Lehetnek √°lnevek (aliasok) (pl. a valami1.hu √©s a valami2.hu is a valami.hu-ra vezet)
- Ugyan√≠gy a levelez≈ë szerverek nev√©t is el lehet fedni vele.
- Elosztja a terhel√©st. A Googlenek p√©ld√°ul nem egy szervere van hanem mondjuk legyen p√©ld√°ul 100. Mindig arra a szerverre lesz ir√°ny√≠tva a felhaszn√°l√≥, ami √©pp k√∂zel van, √©s ami √©pp nem t√∫lterhelt.

DNS adatb√°zis elosztott √©s hierarchikus, vagyis:

![DNS hierarchi√°t √°br√°zol√≥ k√©p](https://i.ibb.co/mSHmbhW/dns-hierarchy.png)

Ha kell a `google.com`, akkor elmegy√ºnk a roothoz, onnan a com-hoz, onnan pedig a google valamelyik szerver√©hez.

A Domain n√©v felold√°sa t√∂rt√©nhet iterat√≠van vagy rekurz√≠van:

![DNS felold√°st szeml√©ltet≈ë √°bra](https://i.ibb.co/mGBJ4n7/dns-feloldas.png)

Itt is van **Cache** a folyamatok gyors√≠t√°s√°ra, k√∂nny√≠t√©s√©re.

Vil√°gszerte 13 **root** szerver van. Ezek ismerik a **TLD** szerverek c√≠meit.

**TLD ‚Äì Top Level Domain** :

- com, org, net, edu, hu, it, de √©s a t√∂bbi.

Fontosabb DNS bej√©gyz√©s t√≠pusok, amik a **dig** parancsos laborn√°l el≈ëj√∂hetnek:

**A** ‚Äì IPv4 c√≠m

**AAAA** ‚Äì IPv6 c√≠m

**MX** ‚Äì levelez≈ë szerver √°lneve
